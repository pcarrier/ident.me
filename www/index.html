<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="/favicon.ico" rel="shortcut icon" type="image/x-icon" />
    <title>My public IP addresses &amp; browser data</title>
    <style>
      :root {
        --color-primary: #0077b6;
        --color-bg: #ddd;
        --color-white: #fff;
        --color-text: #333;
        --color-success: #4caf50;
        --color-info: #2196f3;

        --layout-max: 65rem;
        --layout-section: 20rem;

        --space-xs: 0.2rem;
        --space-sm: 0.5rem;
        --space-md: 1rem;

        --radius: 0.5rem;
        --shadow: 0 0 0.5rem rgb(0 0 0 / 0.1);

        --font-sm: 0.75rem;
        --font-base: 1rem;
        --font-lg: 1.2rem;
        --font-xl: 1.5rem;
      }

      body {
        font-family: system-ui, sans-serif;
        font-variant-numeric: tabular-nums;
        background: var(--color-bg);
        margin: 0;
      }

      a {
        text-decoration: none;
      }

      button:focus-visible,
      a:focus-visible {
        outline: 2px solid var(--color-primary);
        outline-offset: 2px;
      }

      h1 {
        text-align: center;
        background: #0077b6;
        color: #fff;
        padding: var(--space-sm) 0;
        margin: 0;
        font-size: var(--font-xl);
      }

      h2 {
        margin: 0;
        color: #0077b6;
        font-size: var(--font-lg);
      }

      h3 {
        margin: 0;
        font-size: var(--font-base);
      }

      dt {
        font-weight: bold;
      }
      dd {
        margin: 0 0 var(--space-xs) var(--space-sm);
      }
      pre {
        white-space: pre-wrap;
        margin: 0;
      }

      iframe {
        border: 0;
        width: 100%;
        max-width: 50svmin;
        height: auto;
        aspect-ratio: 1;
        border-radius: var(--radius);
      }

      .stats {
        max-width: var(--layout-max);
        margin: 0 auto;
        padding: var(--space-sm);
        display: none;
        grid-template-columns: repeat(auto-fit, minmax(min(100%, 30rem), 1fr));
        gap: var(--space-md);
        font-size: var(--font-sm);
      }

      .stats.visible {
        display: grid;
      }

      .intro {
        text-align: center;
        font-style: italic;
      }

      .section {
        background: #fff;
        flex: 1;
        min-width: var(--layout-section);
        padding: var(--space-sm);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
      }

      main {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-sm);
        max-width: var(--layout-max);
        margin: 0 auto;
        padding: var(--space-sm);
      }

      #docs {
        text-align: center;
        margin: var(--space-sm);
      }

      .stats-link {
        display: inline-flex;
        align-items: center;
      }

      .stats-link .arrow {
        transition: transform 0.2s;
      }
      .stats-link.expanded .arrow {
        transform: rotate(180deg);
      }

      .stats article {
        background: #fff;
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: var(--space-sm);
        display: grid;
        gap: var(--space-sm);
        align-content: start;
      }

      .stats canvas {
        width: 100%;
        height: 3rem;
      }

      .agent {
        cursor: default;
      }

      .agent:hover {
        text-decoration: underline;
      }

      @keyframes pulse {
        0% {
          opacity: 0.5;
        }
        50% {
          opacity: 1;
        }
        100% {
          opacity: 0.5;
        }
      }

      .loading {
        font-style: italic;
        animation: pulse 1s ease-in-out infinite;
      }

      #geolocate {
        display: none;
      }
    </style>
  </head>
  <body>
    <h1>My public IP addresses &amp; browser data</h1>
    <p class="intro">
      For plain text, please use
      <a href="https://4.ident.me">4.ident.me</a> (IPv4),
      <a href="https://6.ident.me">6.ident.me</a> (IPv6), or
      <a href="https://a.ident.me">a.ident.me</a> (either).
    </p>
    <main>
      <div class="section">
        <h2>IPv4</h2>
        <div id="v4"></div>
      </div>
      <div class="section">
        <h2>IPv6</h2>
        <div id="v6"></div>
      </div>
      <div class="section">
        <h2>Browser data</h2>
        <div id="browser">
          <dl>
            <dt>Language</dt>
            <dd>
              <script>
                document.write(navigator.language);
              </script>
            </dd>
            <dt>Timezone</dt>
            <dd>
              <script>
                document.write(
                  Intl.DateTimeFormat().resolvedOptions().timeZone
                );
              </script>
            </dd>
            <dt>JS user agent</dt>
            <dd>
              <script>
                document.write(navigator.userAgent);
              </script>
            </dd>
            <dt>Display</dt>
            <dd>
              <script>
                document.write(
                  `${screen.width}√ó${screen.height}√ó${screen.colorDepth}${
                    devicePixelRatio && devicePixelRatio != 1
                      ? ` @ ${devicePixelRatio.toPrecision(3)} pixel ratio`
                      : ""
                  }`
                );
              </script>
            </dd>
            <dt>Headers</dt>
            <dd>
              <span class="loading" id="headers-loading">Loading‚Ä¶</span>
              <pre id="headers" class="loading"></pre>
              <script>
                fetch("https://srv.us/h")
                  .then((response) => response.text())
                  .then((text) => {
                    const headers = document.getElementById("headers");
                    headers.classList.remove("loading");
                    headers.innerHTML = text;
                    document.getElementById("headers-loading").remove();
                  });
              </script>
            </dd>
            <dt>Coordinates</dt>
            <dd id="browsercoord"><em>Unknown</em><br/></dd>
          </dl>
          <div id="browsermap"></div>
          <button id="geolocate">Geolocate me</button>
        </div>
      </div>
    </main>
    <p style="text-align: center">
      <label><input type="checkbox" id="show-maps" /> Show maps</label>
    </p>
    <p id="docs"></p>
    <div class="stats">
      <p class="loading">Loading‚Ä¶</p>
    </div>
    <script>
      const mirror = location.hostname.substring(4);
      const other = mirror === "ident.me" ? "tnedi.me" : "ident.me";
      const delta = 1;

      // Utility functions
      const escapeHTML = str => str.replace(/[&<>"']/g, m => ({
        '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'
      })[m]);

      const createMapIframe = (lat, long) => {
        const bbox = `${long - delta},${lat - delta},${long + delta},${lat + delta}`;
        return `
          <iframe 
            referrerpolicy="no-referrer-when-downgrade" 
            src="https://www.openstreetmap.org/export/embed.html?marker=${lat},${long}&bbox=${bbox}"
            allowfullscreen
            title="Location map">
          </iframe>
        `;
      };

      // IP Data rendering
      const renderIPData = ({
        ip, aso, asn, continent, cc, country, city, postal, latitude, longitude, tz
      }) => `
        <dl>
          <dt>Address</dt>
          <dd>
            <code>
              <a href="#" class="copy" data-copy="${ip}">
                ${ip}<span class="copy-icon" aria-hidden="true">üìã</span>
              </a>
            </code>
          </dd>
          <dt>Autonomous System (ISP)</dt>
          <dd><a href="https://bgpview.io/asn/${asn}" target="_blank">${aso} (${asn})</a></dd>
          <dt>Timezone</dt><dd>${tz}</dd>
          <dt>Continent</dt><dd>${continent}</dd>
          <dt>Country</dt><dd>${country} (${cc})</dd>
          <dt>City</dt><dd>${city ?? "<i>unknown</i>"}</dd>
          <dt>Postal code</dt><dd>${postal ?? "<i>unknown</i>"}</dd>
          <dt>Coordinates</dt><dd>${latitude}, ${longitude}</dd>
        </dl>
        <div class="map-container" data-lat="${latitude}" data-long="${longitude}"></div>
      `;

      // Initialize page
      document.getElementById("docs").innerHTML = `
        running on <a href="https://pcarrier.com">‚ù§Ô∏è</a> &amp; <a href="https://github.com/sponsors/pcarrier">sponsorships</a> since 2012<br/>
        <a href="//api.${mirror}">documentation (apps, APIs, privacy, etc.)</a> ‚Äî
        <a href="//www.${other}">mirror</a> ‚Äî
        <a href="#" class="stats-link" onclick="toggleStats(event)">stats <span class="arrow">‚ñº</span></a>
      `;

      // Fetch and render IP data
      async function fetchIPData(version) {
        const elem = document.getElementById(version);
        elem.innerHTML = '<p class="inter loading">Loading‚Ä¶</p>';

        try {
          const res = await fetch(`https://${version}.ident.me/json`);
          if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
          elem.innerHTML = renderIPData(await res.json());
          updateMaps(localStorage.getItem("showMaps") === "true");
        } catch (error) {
          elem.innerHTML = `<p class="error">Error: ${error.message}</p>`;
          console.error(`Failed to fetch ${version} data:`, error);
        }
      }

      ["v4", "v6"].forEach(fetchIPData);

      // Copy functionality
      document.addEventListener("click", async e => {
        if (!e.target.matches(".copy")) return;
        e.preventDefault();
        
        try {
          await navigator.clipboard.writeText(e.target.dataset.copy);
          const icon = e.target.querySelector(".copy-icon");
          icon.textContent = "‚úÖ";
          setTimeout(() => icon.textContent = "üìã", 1000);
        } catch (err) {
          console.error("Failed to copy:", err);
        }
      });

      // Geolocation handling
      function getLocation() {
        navigator.geolocation.getCurrentPosition(
          ({ coords: { latitude, longitude } }) => {
            document.getElementById("browsercoord").innerHTML = `${latitude}, ${longitude}`;
            const browserMap = document.getElementById("browsermap");
            Object.assign(browserMap.dataset, { lat: latitude, long: longitude });
            browserMap.className = "map-container";

            if (localStorage.getItem("showMaps") === "true") {
              browserMap.innerHTML = createMapIframe(latitude, longitude);
            }
          },
          error => {
            console.error("Geolocation error:", error);
            showGeolocateButton();
          }
        );
      }

      // ... rest of the existing code for stats and charts ...

      // Map visibility toggle
      const showMapsCheckbox = document.getElementById("show-maps");
      showMapsCheckbox.checked = localStorage.getItem("showMaps") === "true";

      showMapsCheckbox.addEventListener("change", e => {
        const show = e.target.checked;
        localStorage.setItem("showMaps", show);
        document.querySelectorAll(".map-container").forEach(container => {
          container.innerHTML = show ? createMapIframe(Number(container.dataset.lat), Number(container.dataset.long)) : "";
        });
      });

      // Initialize geolocation
      if ("permissions" in navigator) {
        navigator.permissions.query({ name: "geolocation" })
          .then(result => result.state === "granted" ? getLocation() : showGeolocateButton());
      } else {
        showGeolocateButton();
      }

      function showGeolocateButton() {
        const btn = document.getElementById("geolocate");
        btn.style.display = "block";
        btn.onclick = () => {
          getLocation();
          btn.remove();
        };
      }

      function setupCanvas(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;

        const ctx = canvas.getContext("2d");
        ctx.scale(dpr, dpr);
        return ctx;
      }

      async function drawSparkline(canvasId, reqs, ips) {
        const canvas = document.getElementById(canvasId);
        const ctx = setupCanvas(canvas);
        const { width, height } = canvas.getBoundingClientRect();
        const textPadding = 2;
        const circleRadius = 4;
        const graphPadding = circleRadius + 1;
        const fontSize = "1em";

        ctx.font = `${fontSize} sans-serif`;
        const sampleReqsText = `reqs: ${reqs[0].toLocaleString()}`;
        const sampleIpsText = `IPs: ${ips[0].toLocaleString()}`;
        const metrics = ctx.measureText(sampleReqsText);

        const lineHeight =
          metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;
        const textBaseOffset = metrics.actualBoundingBoxAscent;
        const textBoxHeight = (textPadding + lineHeight) * 2;

        const points = [];
        let hoveredPoint = null;

        function drawLine(data, color, yKey, maxValue) {
          const minValue = Math.min(...data);
          const valueRange = maxValue - minValue;

          ctx.beginPath();
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;

          data.forEach((value, i) => {
            const x =
              graphPadding +
              (i * (width - 2 * graphPadding)) / (data.length - 1);
            const y =
              height -
              graphPadding -
              ((height - 2 * graphPadding) * (value - minValue)) / valueRange;

            if (!points[i]) points[i] = { x, reqs: reqs[i], ips: ips[i] };
            points[i][yKey] = y;

            ctx[i === 0 ? "moveTo" : "lineTo"](x, y);
          });
          ctx.stroke();
        }

        function draw() {
          ctx.clearRect(0, 0, width, height);

          drawLine(reqs, "#4CAF50", "y", Math.max(...reqs));
          drawLine(ips, "#2196F3", "y2", Math.max(...ips));

          if (hoveredPoint) {
            ctx.font = `${fontSize} sans-serif`;
            ctx.textAlign = "right";
            ctx.fillStyle = "rgba(255, 255, 255, 0.5)";

            const metrics = ctx.measureText(
              "reqs: " + hoveredPoint.reqs.toLocaleString()
            );
            const boxWidth = metrics.width + textPadding * 2;

            ctx.fillRect(
              width - boxWidth,
              textPadding,
              boxWidth,
              textBoxHeight
            );

            ["reqs", "IPs"].forEach((label, i) => {
              ctx.fillStyle = label === "reqs" ? "#4CAF50" : "#2196F3";
              ctx.fillText(
                `${label}: ${hoveredPoint[
                  label.toLowerCase()
                ].toLocaleString()}`,
                width - textPadding,
                textPadding + textBaseOffset + i * lineHeight
              );
            });
          }
        }

        draw();

        canvas.addEventListener("mousemove", (e) => {
          const rect = canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;

          hoveredPoint = points.reduce((closest, point) => {
            const dist = Math.abs(mouseX - point.x);
            return dist < Math.abs(mouseX - closest.x) ? point : closest;
          });

          draw();

          [
            { y: hoveredPoint.y, color: "#4CAF50" },
            { y: hoveredPoint.y2, color: "#2196F3" },
          ].forEach(({ y, color }) => {
            ctx.beginPath();
            ctx.arc(hoveredPoint.x, y, circleRadius, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
          });
        });

        canvas.addEventListener("mouseleave", () => {
          hoveredPoint = null;
          draw();
        });
      }

      async function toggleStats(event) {
        if (event) {
          event.preventDefault();
        }
        const stats = document.querySelector(".stats");
        const link = document.querySelector(".stats-link");
        const isHidden = !stats.classList.contains("visible");

        if (isHidden) {
          link.classList.add("expanded");
          stats.classList.add("visible");

          if (!stats.dataset.loaded) {
            await fetchAndDrawStats();
            stats.dataset.loaded = "true";
          }
        } else {
          link.classList.remove("expanded");
          stats.classList.remove("visible");
        }
      }

      let resizeTimeout;
      addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          if (document.querySelector(".stats").classList.contains("visible")) {
            fetchAndDrawStats();
          }
        }, 100);
      });

      async function fetchAndDrawStats() {
        const stats = document.querySelector(".stats");

        try {
          const [identStats, tnediStats] = await Promise.all([
            fetch("https://ident.me/stats").then((r) => r.json()),
            fetch("https://tnedi.me/stats").then((r) => r.json()),
          ]);

          stats.innerHTML = `
            <article>
              <h3>ident.me hourly</h3>
              <canvas id="ident-hourly"></canvas>
            </article>
            <article>
              <h3>tnedi.me hourly</h3>
              <canvas id="tnedi-hourly"></canvas>
            </article>
            <article>
              <h3>ident.me daily</h3>
              <canvas id="ident-daily"></canvas>
            </article>
            <article>
              <h3>tnedi.me daily</h3>
              <canvas id="tnedi-daily"></canvas>
            </article>
            <article>
              <h3>ident.me user agents (sampled)</h3>
              <div id="ident-agents"></div>
            </article>
            <article>
              <h3>tnedi.me user agents (sampled)</h3>
              <div id="tnedi-agents"></div>
            </article>
          `;

          await Promise.all([
            drawSparkline(
              "ident-hourly",
              identStats.hourly.reqs,
              identStats.hourly.ips
            ),
            drawSparkline(
              "ident-daily",
              identStats.daily.reqs,
              identStats.daily.ips
            ),
            drawSparkline(
              "tnedi-hourly",
              tnediStats.hourly.reqs,
              tnediStats.hourly.ips
            ),
            drawSparkline(
              "tnedi-daily",
              tnediStats.daily.reqs,
              tnediStats.daily.ips
            ),
          ]);

          const formatAgents = (agents) => {
            return Object.entries(agents)
              .sort(([, a], [, b]) => b - a)
              .map(
                ([agent, count]) =>
                  `<span class="agent">${escapeHTML(
                    agent
                  )} (${count.toLocaleString()})</span>`
              )
              .join(", ");
          };

          document.getElementById("ident-agents").innerHTML = formatAgents(
            identStats.ua
          );
          document.getElementById("tnedi-agents").innerHTML = formatAgents(
            tnediStats.ua
          );
        } catch (err) {
          stats.innerHTML = '<p class="inter">Failed to load stats</p>';
        }
      }

      function updateMaps(show) {
        const containers = document.querySelectorAll(".map-container");
        containers.forEach((container) => {
          if (show && !container.querySelector("iframe")) {
            const { lat, long } = container.dataset;
            container.innerHTML = createMapIframe(Number(lat), Number(long));
          } else if (!show) {
            container.innerHTML = "";
          }
        });
      }
    </script>
  </body>
</html>
